---
title: JS - 型別檢查與隱性轉換
tags:
 - JavaScript
---


型別檢查(Type checking) 會是校驗變數/結構的型別是否符合內容，並回報錯誤或者幫助系統確定變數型別確實是如此，主要是盡可能偵測相關問題並及時給予機會去修正。

## 型別檢查什麼時期執行

型別檢查會發生在編譯期間或者執行期間，若是在編譯期間進行檢查的話，代表所有的程式碼都必須在執行前或者更早之前指定型別給會用到的變數和內容，而開發者可以選擇在開發期間指定型別給每個變數和內容，並在編譯期間讓編譯器去做型別檢查做第二輪的檢查，或者也可以不用開發者去指定，讓編譯期間的編譯器根據內容去做檢查，通常會選擇前者，比較能夠透過額外的資訊和第一輪檢查(開發者)增加型別的正確性。

而若是在執行期間進行檢查的話，代表所有程式碼都是在執行時根據指派內容和一些指派規則來確定變數和內容各是什麼樣的型別，當然地，型別確定可以不限於第一次的型別檢查，還有可能會是根據每次指派內容而變動相同變數的型別，比如說變數a第一次做型別檢查時，是被判定為數字型別，而接著a儲存字串資料，而這時會做二次型別檢查，使變數a轉變為字串型別。


## 靜態語言與動態語言
若某程式語言是在編譯期間進行型別檢查的話，該程式語言會是靜態語言(Statically Typed Languages)；若某程式語言是在執行期間進行的話，該程式語言會是動態語言(Dynamically typed languages)。


## JavaScript 是屬於？

JavaScript由於本身是透過直譯器來執行，無法在編譯時期執行型別檢查，只能選擇在執行期間進行型別檢查以及確定型別，因此它屬於動態語言，JavaScript會根據 "每一次" 的指派內容來指定 “每一次" 的型別檢查和確定型別，這也就是一個變數型別可以根據內容而轉換為JavaScript任意可辨識的型別，使得開發者變得更好開發，但對於結果來說，會容易產生出預期以外結果，比如說由表達式所構成的一個值或者一個物件，該表達式可能有不少的變數、常數、運算符號，其形式會是：var1至varN是變數，constant1至constantN是常數，operator1至operator(N-1)是運算符號，這些參數會構成足以代表一個值或者一個物件的表達式，並將代表的內容傳進value1這變數

```
let value1 = var1/constant1 operator1 var2/constant2 ...... operator(N-1) varN/constantN
```

若這些變數和常數的型別皆為一樣時，我們很容易預估最後結果的型別以及value1變數型別是什麼，但是如果某些變數或者常數的型別是不太一樣時，這時我們就很難預估型別是什麼，得依賴著直譯器對於他們的判定。


### 型別轉換(Type Conversion)

直譯器遇到這些不同型別的變數或者常數時，你可以選擇添加一些轉換型別的語法來為這些變數和常數進行顯性轉換(Type Casting)，但若不添加的話，就是由直譯器負責處理隱性轉換(Type Coercion，不透過較明顯的轉換語法)，而隱性轉換會根據直譯器內部的轉換規則來進行，比如說它會從表達式抽出最優先計算的一部分表達式，通常會是

```
var1/constant1 operator1 var2/constant2
```

並且檢查var1/constant1 和var2/constant2哪一邊是字串，若有字串，整條表達式會以字串形式來進行並以字串來輸出，



### 避免隱性轉換的開發建議

1. 使用顯性轉換
2. 要比較內容時，請使用====或者!==，別使用==或者!=，這會使直譯器繼續使用隱性轉換


A. 表達式中的運算子(operator)大多會取離他們較近的1~2個數值或者物件來計算


B. 看先被處理的資料所擁有的型態以及內容是什麼？ 若取到的資料擁有字串型態，整體就以字串來做處理，
C. 數值運算子處理的優先權，括號優先權最大，其次是乘除，再來就是加減

其內容若能在數值系統表達數字的話，則會被看待為數字型態，否則就依照有沒有字串型態的參數來決定，都沒有的話，會以數字型態來處理，否則就以字串型態

note：


例子1：

```
console.log(100 + false +  '0')
```

系統會先替第一個運算子(operator)抓取100和false，而false在這裡它會試著轉化為數字型態的0，所以會是數字型態的100(100+0)，接著就是100 + '0'，由於'0'本身是字串且無法被轉化成數值，所以會以字串的型態來表達，其最後結果會是'1000'

例子2：

```
console.log('a' + false + 0)
```

一樣地，系統會先第一個運算子抓取了'a'和false，在這裡其中一個單一值為字串，所以字串的形式來處理，其結果會是'afalse'，接下來換下一個運算子，'afalse' + 0，由於'afalse'本身也是字串，所以也是以字串的型態來處理，最後結果為'afalse0'


## 補充資料：

1. 型別轉換(Type conversion)可以是顯性或者隱性轉換，若是顯性轉換的話，會透過較明顯的轉換語法來達到型別轉換，直接由開發者自行決行轉換什麼型別，比如：

```
console.log(100 + Number(false))          // 100 + 0 = 100
```
而若是隱性轉換的話，就如同前面所述，不會透過明顯語法來達到目標，而是由直譯器來決定型別是什麼，比如：
```
console.log(100 + false)                  // 100 + 0 = 100
```


2. 
a. 會在boolean系統視為true的內容，有非空內容的字串、非0的數字、非Null物件。
b. 會在boolean系統視為false的內容，有空字串、0、NaN、null、undefined、false。 
c. 若在boolean系統視為false的內容，可以在數值系統表達0
d. 若在boolean系統視為true的內容，只有true才能表達1


## 參考資料
1. https://developer.mozilla.org/en-US/docs/Glossary/Type_coercion
2. https://stackoverflow.com/questions/8857763/what-is-the-difference-between-casting-and-coercing
