---
title: U18
tags:
---

Description:
1. 陣列是一個物件(Object)，會以連續記憶體的形式來存放每個元素，也就是說每個元素在記憶體位址會以某個記憶體位址addr為主軸以及偏移值，也由於陣列是物件，它會有一定數量的屬性和方法，比如length這屬性以及push這方法。

[需要圖來說明主軸＋偏移值]

2. 陣列中的每個元素會跟一個數字index來綁定，第一個元素會跟0做綁定，第二個元素會跟1做綁定，後面依此類推

Question: 若陣列存在多個不同型別的資料時，其index是如何實作？



/*
2. 由於記憶體位址上是呈現第一點所述，第一個元素的記憶體位址所在是在addr，而偏移值為0 ，第二個元素的記憶體位址所在是在addr + 1，其中1為偏移值，而第N個元素的所在就是addr＋(N-1)，(N-1)為偏移值，而偏移值在系統裡會以index的形式來表達，

*/

3. 陣列宣告以及如何存取：我們可以利用以下方法來宣告陣列並指派一些內容給他，其語法會是如下所示：
```
let arrname = [value1, ..... , value N]
```

value1, .... value N可以填入任意值，也能放入不同型別的資料，例子：

```
let arr = [] // 定義空陣列

let arr1 = [1, 2, 3, 4] // 1, 2, 3, 4放入陣列
 
let arr2 = [2, 3, '56', 12] // 2, 3, '56', 12放入陣列，其中'56'是字串。
``` 


當我們想存取或者更動陣列中某個元素時，比如說存取第N個元素，只需要下達

```
arr[N - 1] = value1
```

```
console.log(arr[N - 1])
```

就能順利存取該元素


4. array擁有幾種常見的屬性，比如可以回傳陣列長度或者陣列有多少個元素的length，
使用方法為

```
array.length
```


可以搭配該屬性和for迴圈來遍歷陣列中的每個元素，比如透過以下語法來印出陣列中的每個元素。

```
let array = [1, 2, 3, 4, 5, 6, 7]

for (let index = 0; index < array.length. index++) {

	console.log(array[index])
}
```

5. 陣列擁有可以被當作stack或者queue的方法，push方法和pop方法分別代表著stack常見的push和pop，而shift方法和unshift方法則是分別代表著queue常見的dequeue和enqueue，而這四個方法都會確實更動陣列中的元素。

陣列的push方法會從陣列尾部添加元素，而pop方法則是從陣列尾部後取出值，相當符合stack的後進先出的特性，比如說：

```
let array = [1, 2, 3, 4, 5]
array.push(6)
```

會在5之後添加6，而若是pop且陣列內容維持push之前的狀態的話，會把5這個元素給去掉
```
array.pop()
```

陣列的unshift方法則將目前在陣列的所有元素都往後移一個，使新增的元素放入第一個位置，而shift方法則將目前陣列上的第一個元素取出來，然後將剩餘的元素都往前移一格，比如說：假設一個陣列內容為1,2,3,4,5的陣列，我們要對它做shift或者unshift處理

```
let array = [1, 2, 3, 4, 5]
array.shift()
```

當執行shift時，會從陣列取出1這個數字，然後2,3,4,5都會往前面移動，使陣列內容變成：

```
array = [2, 3, 4, 5]
```

若我們將array內容繼續維持1,2,3,4,5，然後對它執行unshift(value1)時，

```
let array = [1, 2, 3, 4, 5]
array.unshift(value1)
```

這會使陣列中的1,2,3,4,5都往後移一格，然後讓出空間存放value1，其陣列內容為：

```
array = [value1, 1, 2, 3, 4, 5]
```

6. 其他方法：splice方法、slice方法、concat方法，第一個方法主要會移除或增加元素至指定位置，而第二個方法則是從陣列裡擷取想要的內容，最後一個方法則是將陣列合併成一個新陣列。


7. splice方法的使用會根據參數量和參數值而有所不同，該方法會確實更動到原本陣列內容，其主要語法為：

```
splice(start, deleteCount, item)
```

回傳值主要有：
1. 被刪除的元素 (若deleteCount > 0)
2. 空陣列 (若deleteCount <= 0)

功能上：

1. 若參數量只有一個的話，則會從start所指定的位置而開始刪除內容
2. 若參數量只有兩個的話，則會根據deleteCount的數值來調整函式的用途：若大於0則是刪除，在這情況下，會從start這個位置刪除deleteCount個元素，若deleteCount-start大於length，則是從start刪到最後一個算；而若是小於等於0則是增加，在這情況下，由於沒添增第三個參數，所以會保持原本陣列的內容
3. 若參數量只有三個的話，通常預期功能上是要該函式處理增加元素的部分，所以第二個參數肯定是小於等於0，那麼會在start位置添置第三個參數的內容。

8. 
